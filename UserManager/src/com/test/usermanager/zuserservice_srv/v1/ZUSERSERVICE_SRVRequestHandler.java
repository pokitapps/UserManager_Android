package com.test.usermanager.zuserservice_srv.v1;
/*
 Auto-Generated by SAP NetWeaver Gateway Productivity Accelerator, Version 1.1.1
*/

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.ParseException;
import org.apache.http.message.BasicStatusLine;
import org.apache.http.util.EntityUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.text.TextUtils;
import android.util.Log;

import com.sap.gwpa.proxy.ODataQuery;
import com.sap.gwpa.proxy.RequestStatus;
import com.sap.gwpa.proxy.RequestStatus.StatusType;
import com.sap.gwpa.proxy.ServiceInitializationException;
import com.sap.gwpa.proxy.ServiceNegotiator;
import com.sap.gwpa.proxy.connectivity.ActionHelperDelegateImpl;
import com.sap.gwpa.proxy.connectivity.ConnectivitySettings;
import com.sap.gwpa.proxy.connectivity.ContentTypeHelperDelegateImpl;
import com.sap.gwpa.proxy.connectivity.CredentialsData;
import com.sap.gwpa.proxy.connectivity.CsrfConnectivityHelperDelegateImpl;
import com.sap.gwpa.proxy.connectivity.DataVaultHelper;
import com.sap.gwpa.proxy.connectivity.JsonHelperDelegateImpl;
import com.sap.gwpa.proxy.connectivity.ProxyData;
import com.sap.gwpa.proxy.connectivity.SDMConnectivityHelper;
import com.sap.gwpa.proxy.connectivity.SDMResponseWrapper;
import com.sap.gwpa.proxy.connectivity.SUPHelper;
import com.sap.gwpa.proxy.connectivity.SUPHelperException;
import com.sap.gwpa.proxy.connectivity.authenticators.AuthenticatingException;
import com.sap.gwpa.proxy.connectivity.authenticators.FormBasedSAMLAuthenticator;
import com.sap.gwpa.proxy.connectivity.authenticators.IAuthenticator;
import com.sap.gwpa.proxy.connectivity.authenticators.PortalAuthenticator;
import com.sap.gwpa.proxy.connectivity.authenticators.UsernamePasswordAuthenticator;
import com.sap.mobile.lib.configuration.IPreferences;
import com.sap.mobile.lib.configuration.Preferences;
import com.sap.mobile.lib.configuration.PreferencesException;
import com.sap.mobile.lib.parser.IODataServiceDocument;
import com.sap.mobile.lib.parser.ParserException;
import com.sap.mobile.lib.request.BaseRequest;
import com.sap.mobile.lib.request.ConnectivityException;
import com.sap.mobile.lib.request.INetListener;
import com.sap.mobile.lib.request.IRequest;
import com.sap.mobile.lib.request.IRequestStateElement;
import com.sap.mobile.lib.request.IResponse;
import com.sap.mobile.lib.request.RequestStateElement;
import com.sap.mobile.lib.request.ResponseImpl;
import com.sap.mobile.lib.sdmconfiguration.ISDMPreferences;
import com.sap.mobile.lib.sdmconfiguration.SDMConstants;
import com.sap.mobile.lib.sdmconfiguration.SDMPreferences;
import com.sap.mobile.lib.supportability.ILogger;
import com.sap.mobile.lib.supportability.ISDMLogger;
import com.sap.mobile.lib.supportability.Logger;
import com.test.usermanager.zuserservice_srv.ServiceVersionConfigurations;
import com.test.usermanager.zuserservice_srv.v1.entitytypes.User;
import com.test.usermanager.zuserservice_srv.v1.helpers.IZUSERSERVICE_SRVRequestHandlerListener;
import com.test.usermanager.zuserservice_srv.v1.helpers.ListenerWrapper;
import com.test.usermanager.zuserservice_srv.v1.helpers.ZUSERSERVICE_SRVRequestID;
 
/**
 * Abstract: A singleton class responsible for sending the appropriate service requests 
 * (for retrieving and modifying service data) and parsing the responses into semantic objects, 
 * using the service proxy and the SDMConnectivityHelper class. 
 * The sent requests also consider the service URL and the SAP client defined in the application settings. 
 * The class is also responsible for sending the appropriate notifications to the application delegate 
 * and view controllers, for handling the request success, failure and authentication challenge.  
 */
public class ZUSERSERVICE_SRVRequestHandler implements INetListener
{
 	private static final String GWPA_ACTION = "gwpa-action";
    private static final String GWPA_BATCH_ACTION = "gwpa-batch-action";
    private static final String BATCH = "batch";
 	private static final String TAG = "ZUSERSERVICE_SRVRequestHandler";
 
    // Application context
    private static android.content.Context context;
    
    // The Request Handler's SDM Connectivity Helper
    private SDMConnectivityHelper connectivityHelper;
    
    // The service proxy
    private ZUSERSERVICE_SRVService service;
    
    // The service document URL
    private String serviceDocumentURL;
    
    // The sap-client, null is default
    private String SAPClient; 
    
    // SDM Logger
    private ILogger logger;
    
    // Proxy Data
    private ProxyData proxyData;
    
    // The authenticator 
    private IAuthenticator authenticator;

    // Server Certificate resource id
    private int[] certid;

    // Indicates if the service proxy is initialized using local metadata.
    private boolean useLocalMetadata;
        
    // Indicates if the service negotiation process should be performed. This is considered only when the useLocalMetadata property is set to false.
    private boolean useServiceNegotiation;
    
    private ServiceNegotiator serviceNegotiator;
    
    // A map that holds RequestID as keys and Objects
    // that represent the Source object as values.
    // The object may be null.
    private Map<ZUSERSERVICE_SRVRequestID, Object> requestsIdentifierMap;
    
    // Holds all the listeners of this request handler
    private List<ListenerWrapper> listenerWrappers;
    
    // Indicates if the service uses Json or Xml
    private boolean useJson = false;
    
    private JsonHelperDelegateImpl jsonHeadersDelegate = new JsonHelperDelegateImpl();
    private boolean isJsonHelperDelegateWasAdded = false;
    
    // Indicates whether the login process succeeded or not
    private boolean isLoginSucceeded = false;
    
    /*
     * Private constructor for the singleton class
     */
	private ZUSERSERVICE_SRVRequestHandler()
	{
	    try
	    {
	        // initialization
	        this.useLocalMetadata = false;
	    	this.useServiceNegotiation = true;
	        this.logger = new Logger();
	        this.service = new ZUSERSERVICE_SRVService(context); 
	        
	        /*
             * ****** TODO: If using SSL add the server certificate to res/raw folder and uncomment the line below 
             * to pass the resource id.
             * ******
             */
//	        certid = new int[]{R.raw.sslcert};
//	        this.proxyData = new ProxyData(); 
//			this.proxyData.setHost("hostName");  
//			this.proxyData.setPort(portNumber);
//			this.proxyData.setBypassProxy("BypassProxy"); 
	        
	        /*
             * ****** TODO: In-order to work with GWaaS service use FormsBasedSAMLAuthenticationType
             * ******
             */
//			ConnectivitySettings.getInstance().setAuthenticationType(AuthenticationType.FormsBasedSAMLAuthenticationType);
			
	        this.connectivityHelper = new SDMConnectivityHelper(context, certid, proxyData);
	        this.connectivityHelper.getParameters().setAutoRedirectEnabled(false);
	        this.serviceDocumentURL = this.service.getBaseUrl();
	        this.listenerWrappers = new ArrayList<ListenerWrapper>();
	        this.requestsIdentifierMap = new HashMap<ZUSERSERVICE_SRVRequestID, Object>();
	        registerSDMConnectivityHelperDelegate();
	        
	        connectivityHelper.getPreferences().setIntPreference( IPreferences.CONNECTIVITY_CONNTIMEOUT, 60000);
			
			connectivityHelper.getPreferences().setIntPreference(IPreferences.CONNECTIVITY_SCONNTIMEOUT, 360000);
	    }
	    catch(ExceptionInInitializerError e) 
	    {
	        this.logger.e(TAG, "Failed to create a service proxy: " + e.getLocalizedMessage());
	    } 
	    catch (PreferencesException e) 
        {
	        this.logger.e(TAG, "Failed to create SDMPreferences: " + e.getLocalizedMessage());
        }
	}
	
	private void registerSDMConnectivityHelperDelegate() 
	{
		if (this.service.getBaseUrl().contains("odata"))
		{
			this.connectivityHelper.registerSDMConnectivityHelperDelegate(new CsrfConnectivityHelperDelegateImpl(this.service.getBaseUrl()));
		}
	}
	
	/*
	 * Holder for the singleton class
	 */
	private static class ZUSERSERVICE_SRVRequestHandlerHolder
	{
		public static final ZUSERSERVICE_SRVRequestHandler requestHandler = new ZUSERSERVICE_SRVRequestHandler();
	}
	
	
	/**
	 * Returns the instance of the singleton class,
	 * and initializes the application context, if it wasn't initialized before.
	 * 
	 * @param givenContext - application context
	 * @return - the instance of the Request Handler
	 */
	public static ZUSERSERVICE_SRVRequestHandler getInstance(android.content.Context givenContext)
	{
	    if (context == null)
	    {
	        context = givenContext;
	    }
	    
		return ZUSERSERVICE_SRVRequestHandlerHolder.requestHandler;
	}
	
	
	/**
	 * Authenticates the given user name and password against the service. 
	 * Make sure to call this method before calling any other method 
	 * of this class for executing service requests.
	 * 
	 * @param username - the user name
	 * @param password - the password
	 * @param vaultPassword - vault password value. Needed when working in SUP mode.
     * @param vaultSalt - vault salt value. Needed when working in SUP mode.
	 * @return - true whether the login has succeeded, and false otherwise
	 * @throws ServiceInitializationException - in case the service proxy wasn't initialized properly.
	 * @throws SUPHelperException 
	 */
	public boolean executeLoginUsernamePassword(String username, String password, String vaultPassword, String vaultSalt) throws ServiceInitializationException, SUPHelperException
	{
		removeJsonHeaders();
	    this.isLoginSucceeded = false;
	    	    
	    // validate service proxy
	    if (this.useLocalMetadata && this.service == null)
        {
	        this.logger.e(TAG, "Error while trying to execute login, the service proxy was null");
	        throw new ServiceInitializationException("The service proxy is null");
        }
	    
        try
        {        
        	// activate required authentication type
        	authenticator = activateAuthentication(username, password, vaultPassword, vaultSalt);
        	// add SAP client provided by the developer
        	authenticator.setSAPClient(this.SAPClient);
        	Log.d("TEST", "SAP client : " + this.SAPClient );
        	if (ConnectivitySettings.getInstance().isSUPMode())
            {
            	setURLAndClientWithSUPApplicationEndPoint();
            }
        	
        	// validate service URL (set by the developer, or from the local service document, or from SUP application end point)
    	    if ((this.serviceDocumentURL == null) || (this.serviceDocumentURL.length() == 0))
    	    {
    	        this.logger.e(TAG, "Error while trying to execute login, the service document URL was not set properly in the proxy");
    	        throw new ServiceInitializationException("The service document URL was not set properly");
    	    }
            
            // In case local metadata is used, it's enough to call authenticator to validate credentials 
    	    // without parsing the response
            if (this.useLocalMetadata)
            {
            	if (ConnectivitySettings.getInstance().isSUPMode())
            		{
            			this.serviceDocumentURL = serviceDocumentURL.substring(0, serviceDocumentURL.length()-1);
            		}
            		
            	// Get service document using the authenticator (negotiation is not supported in this scenario):
                String serviceDocumentData = authenticator.authenticate(new ODataQuery(this.serviceDocumentURL));                
                if (serviceDocumentData != null) 
                {
                	setConnectivityCredentials(username, password, vaultPassword, vaultSalt);
                	this.isLoginSucceeded = true;
                	if(this.useJson)
                	{
                		addJsonHeaders();
                	}
                	return true;
                }
                else
                {
                	return false;
                } 
            }
            else
            {
                // In case local metadata is not used, negotiate the best matching service version, 
                // get the service data, the service metadata, and re-initialize the service proxy object
            	
            	// Negotiate using the authenticator:
            	boolean serviceNegotiationResult = negotiateServiceVersionAndUpdateServiceDocumentUrl(authenticator);
            	String serviceDocumentData = null;
            	if (serviceNegotiationResult)
            	{
            		this.logger.i(TAG, "Service negotiation succeeded.");
            		setConnectivityCredentials(username, password, vaultPassword, vaultSalt);
            		// Get service document without authenticator
            		serviceDocumentData = executeServiceDocumentRequest();
            	}
            	else 
            	{
            		if (ConnectivitySettings.getInstance().isSUPMode())
            		{
            			this.serviceDocumentURL = serviceDocumentURL.substring(0, serviceDocumentURL.length()-1);
            		}
            		
                    // Get service document using the authenticator (as negotiation failed or skipped)
            		serviceDocumentData = authenticator.authenticate(new ODataQuery(this.serviceDocumentURL));                
                    if (serviceDocumentData != null) 
                    {
                    	setConnectivityCredentials(username, password, vaultPassword, vaultSalt);
                    }
            	}
            	
            	// Get service metadata and use it to init the service proxy object:           	           	           	
            	if (serviceDocumentData != null) 
            	{
	            	String serviceMetadataData = executeServiceMetadataRequest();
	        		if (serviceMetadataData != null)
	        		{
	        			this.service = new ZUSERSERVICE_SRVService(context, serviceDocumentData, serviceMetadataData);
	        			this.service.setUrl(this.serviceDocumentURL);
	        			this.isLoginSucceeded = true;
	                	if(this.useJson)
	                	{
	                		addJsonHeaders();
	                	}
	        			return true;
	        		}
	        		else
	        		{
	        			return false;
	        		}
            	}
            	else
            	{
            		return false;
            	}
            }
        } 
        catch (AuthenticatingException e)
        {
            this.logger.e(TAG, "Failed to perform login: " + e.getLocalizedMessage());
            return false;
        }
        catch (MalformedURLException e)
        {
            this.logger.e(TAG, "Failed to perform login: " + e.getLocalizedMessage());
            return false;
        }         
	}
	
	/**
	 * logout the user saved on the device.  
	 * 
	 * @throws SUPHelperException 
	 */
	public void logout() throws AuthenticatingException
	{
		if (authenticator == null)
		{
    		throw new AuthenticatingException("Logout must be called after login.");
		}
		
		try 
		{
			authenticator.clearAuthenticationData();
		} 
		catch (AuthenticatingException e) 
		{
            this.logger.e(TAG, "Error while performing unregistration from SUP or deleting credentials from vault: " + e.getLocalizedMessage());
    		throw e;
		}
		
	}
	
	/**
	 * Updates the service document URL with the result of the best matching service query of the Gateway service catalog.
	 * Is performed as part of the login process (in the executeLoginUsernamePassword method), if the useServiceNegotiation property is set to true.
	 * @param authenticator - The implementation of Authenticating protocol according to the required authentication method.
	 * @return - boolean indicating if service negotiation succeeded.
	 */
	public boolean negotiateServiceVersionAndUpdateServiceDocumentUrl(IAuthenticator authenticator)
	{
		if (!this.useServiceNegotiation) 
		{
			this.logger.i(TAG, "Skipping service negotiation process.");
			return false;
		}
			
		// Initialize service negotiation object
		try 
		{
			this.serviceNegotiator = new ServiceNegotiator(this.serviceDocumentURL, ServiceVersionConfigurations.CATALOG_SERVICE_URL);
		} 
		catch (MalformedURLException e) 
		{
			this.logger.e(TAG, e.getLocalizedMessage());
		} 
		catch (UnsupportedEncodingException e) 
		{
			this.logger.e(TAG, e.getLocalizedMessage());
		}
		
		if (this.serviceNegotiator == null)
		{
			this.logger.i(TAG, "ServiceNegotiator was not initialized. Skipping service negotiation process.");
			return false;
		}
		
		this.serviceNegotiator.setTechnicalServiceName(ServiceVersionConfigurations.TECHNICHAL_SERVICE_NAME);
		this.serviceNegotiator.setTechnicalServiceVersionMax(ServiceVersionConfigurations.TECHNICHAL_SERVICE_VERSION_MAX);
		this.serviceNegotiator.setTechnicalServiceVersionMin(ServiceVersionConfigurations.TECHNICHAL_SERVICE_VERSION_MIN);
		
		String negotiationResponse = null;
		try 
		{
			negotiationResponse = this.executeServiceNegotiationRequest(authenticator);
		} 
		catch (MalformedURLException e) 
		{
			this.logger.e(TAG, "Failed to execute service negotiation: " + e.getLocalizedMessage());
		} 
		catch (AuthenticatingException e) 
		{
			this.logger.e(TAG, "Failed to execute service negotiation: " + e.getLocalizedMessage());
		}
		
		if (negotiationResponse != null && negotiationResponse.length() != 0) 
		{
			if (this.serviceNegotiator.parseBestMatchingServiceResult(negotiationResponse)) 
			{
				String bestMatchingServiceUrl = this.serviceNegotiator.getBestMatchingServiceUrl();
				if (bestMatchingServiceUrl != null && bestMatchingServiceUrl.length() != 0) 
				{
					this.logger.i(TAG, "Service negotiation process completed successfully. Updating service document URL.");
					setServiceDocumentURL(bestMatchingServiceUrl);
					// Make sure the service negotiation process runs only once.
					this.useServiceNegotiation = false;
					return true;
				}
			}
		}
		
		return false;
	}
	
	private String executeServiceNegotiationRequest(IAuthenticator authenticator) throws MalformedURLException, AuthenticatingException
	{
		ODataQuery query = this.serviceNegotiator.getBestMatchingServiceQuery();
		
		if (query != null) 
		{
			return authenticator.authenticate(query);
		}
		
		return null;
	}

	/*
	 * Activates the right authentication protocol based on the configuration settings.
	 */
	private IAuthenticator activateAuthentication(String username, String password, String vaultPassword, String vaultSalt) throws AuthenticatingException
	{
	    // in case in SUP mode, authentication type is defined between SUP Server and Gateway, so we need a simple UsernamePasswordAuthenticator
	    if(ConnectivitySettings.getInstance().isSUPMode()) 
	    {
	        return activateUsernamePasswordAuthentication(username, password, vaultPassword, vaultSalt, certid, proxyData);
	    }
	    else 
	    {
	    	switch (ConnectivitySettings.getInstance().getAuthenticationType()) 
	    	{
			case UsernamePasswordAuthenticationType:
		        return activateUsernamePasswordAuthentication(username, password, vaultPassword, vaultSalt, certid, proxyData);
			case PortalAuthenticationType:
		        return activatePortalAuthentication(username, password, vaultPassword, vaultSalt, certid, proxyData);
		    case FormsBasedSAMLAuthenticationType:
		    	return activateFormBasedSAMLAuthentication(username, password, vaultPassword, vaultSalt, certid, proxyData);
			default:
				return activateUsernamePasswordAuthentication(username, password, vaultPassword, vaultSalt, certid, proxyData);
			}
	    }
	}
	
	/*
	 * Activates the Portal authentication.
	 */
	private IAuthenticator activatePortalAuthentication(String username,
			String password, String vaultPassword, String vaultSalt, int[] certid, ProxyData proxyData) throws AuthenticatingException 
	{
		return new PortalAuthenticator(username, password, context, vaultPassword, vaultSalt, certid, proxyData);
	}
	
	/*
	 * Activates the UsernamePassword authentication.
	 */
	private IAuthenticator activateUsernamePasswordAuthentication(String username, String password, String vaultPassword, String vaultSalt, int[] certid, ProxyData proxyData) throws AuthenticatingException
	{
	    return new UsernamePasswordAuthenticator(username, password, context, vaultPassword, vaultSalt, certid, proxyData);
	}
	
	/*
	 * Activates the GWaaS SAML authentication.
	 */
	private IAuthenticator activateFormBasedSAMLAuthentication(String username, String password, String vaultPassword, String vaultSalt, int[] certid, ProxyData proxyData) throws AuthenticatingException
	{
	    return new FormBasedSAMLAuthenticator(username, password, context, vaultPassword, vaultSalt, certid, proxyData);
	}
	
    public boolean isLoginSucceeded() {
		return isLoginSucceeded;
	}

	public void setLoginSucceeded(boolean isLoginSucceeded) {
		this.isLoginSucceeded = isLoginSucceeded;
	}
	
	// Indicates if the service uses Json or Xml
	public boolean isUseJson() {
		return useJson;
	}

	// call this method after the login process ends
	public void setUseJson(boolean useJson) {
		this.useJson = useJson;
		if(this.useJson && this.isLoginSucceeded)
		{
			addJsonHeaders();
		}
		else if(!this.useJson)
		{
			removeJsonHeaders();
		}
	}
	
	private void addJsonHeaders() 
	{
		if(!isJsonHelperDelegateWasAdded)
		{
	        this.connectivityHelper.registerSDMConnectivityHelperDelegate(jsonHeadersDelegate);
	        isJsonHelperDelegateWasAdded = true;
		}
	}
	
	
	private void removeJsonHeaders() 
	{
		this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(jsonHeadersDelegate);
		isJsonHelperDelegateWasAdded = false;
	}
	
	
	/*
	 * Set the appropriate credentials parameters in the connectivity helper for further requests, 
	 * after first successful call using an authenticator.
	 * In case of non-SUP connectivity mode, we keep using null username and password (as the session cookie is used).
	 * in SUP connectivity mode, where there is no session cookie, the authentication credentials should be passed with any request.
	 */
	private void setConnectivityCredentials(String username, String password, String vaultPassword, String vaultSalt) throws SUPHelperException
	{
        if (ConnectivitySettings.getInstance().isSUPMode())
        {
             if (TextUtils.isEmpty(username) || TextUtils.isEmpty(password))
             {
                   DataVaultHelper dataVaultHelper = DataVaultHelper.getInstance(context);
                   if (dataVaultHelper.isCredentialsSaved(vaultPassword, vaultSalt))
                   {
						// get the user name and password from the vault
						CredentialsData userCredentialsFromDataVault = dataVaultHelper.getUserCredentialsFromDataVault(vaultPassword, vaultSalt);
						username = userCredentialsFromDataVault.getUsername();
						password = userCredentialsFromDataVault.getPassword();
                   }
             }
             
             this.connectivityHelper.setConnectivityParameters(username, password, true);
        }
        else
        {
             this.connectivityHelper.setConnectivityParameters(username, password, true);
        }
	}
	
	private void setURLAndClientWithSUPApplicationEndPoint() throws SUPHelperException
	{
		String applicationEndpoint = null;
		
		try 
		{
			applicationEndpoint = SUPHelper.getServiceUrl();
		} 
		catch (SUPHelperException e) 
		{		
			this.logger.e(TAG, "Failed to retrieve application endpoint from SUP. " + e.getLocalizedMessage());
			throw e;
		}
		
		int urlParametersIndex =  applicationEndpoint.indexOf("?");
		if (urlParametersIndex == -1)
		{
			setServiceDocumentURL(applicationEndpoint);
			setSAPClient(null);
		}		
		else // found the "?"
		{        
			String serviceUrlValue = applicationEndpoint.substring(0, urlParametersIndex);
			setServiceDocumentURL(serviceUrlValue);// URL without parameters
			
	        // Extract SAP Client parameter:
	        String parameters = applicationEndpoint.substring(urlParametersIndex + 1, applicationEndpoint.length()); 
	        String sapClient = "sap-client=";
	        int sapClientIndex = parameters.indexOf(sapClient); 
	        
	        String clientValue = null;
	        if (sapClientIndex > -1)
	        {	            
	        	clientValue = parameters.substring(sapClientIndex + sapClient.length());

	        	// Remove what's after & or / charachters (if exist) from client value
	        	int indexOfOther = clientValue.indexOf("&");
	            
	        	if (indexOfOther == -1 ) 
	            {
	            	indexOfOther = clientValue.indexOf("/");    
	            }
	     
	            if (indexOfOther > -1 ) 
	            {
	                clientValue = clientValue.substring(0, indexOfOther);
	            }
	        }
        
	        setSAPClient(clientValue);        
		}
	}
	
	private String executeServiceMetadataRequest()
	{
		String serviceMetadataUrl = serviceDocumentURL + "/$metadata";
		String responseString = null;
		
        ODataQuery query;
		try 
		{
			query = new ODataQuery(serviceMetadataUrl);
			SDMResponseWrapper response = this.connectivityHelper.executeBasicSyncRequest(query);
			if (response != null && (!response.getRequestFailed()))
			{				
				IResponse responseData = response.getSdmResponse();
				responseString = EntityUtils.toString(responseData.getEntity(), "UTF-8");
			}				
		} 
		
		catch (MalformedURLException e) 
		{
        	this.logger.e(TAG, "Failed to execute service Metadata request " + e.getLocalizedMessage());
		} 
		catch (ParseException e) 
		{
			this.logger.e(TAG, "Error while parsing the response " + e.getLocalizedMessage());
		} 
		catch (IOException e) 
		{
			this.logger.e(TAG, "Failed to convert the response data " + e.getLocalizedMessage());
		}

		return responseString;
	}
	
	private String executeServiceDocumentRequest()
	{
		String responseString = null;
		
        ODataQuery query;
		try 
		{
			query = new ODataQuery(serviceDocumentURL);
			SDMResponseWrapper response = this.connectivityHelper.executeBasicSyncRequest(query);
			if (response != null && (!response.getRequestFailed()))
			{				
				IResponse responseData = response.getSdmResponse();
				responseString = EntityUtils.toString(responseData.getEntity(), "UTF-8");
			}	
		} 
		
		catch (MalformedURLException e) 
		{
        	this.logger.e(TAG, "Failed to execute service document request " + e.getLocalizedMessage());
		} 
		catch (ParseException e) 
		{
			this.logger.e(TAG, "Error while parsing the response " + e.getLocalizedMessage());
		} 
		catch (IOException e) 
		{
			this.logger.e(TAG, "Failed to convert the response data " + e.getLocalizedMessage());
		}

		return responseString;
	}
	
	/**
	 * Sets the service document URL.
	 * @param serviceDocumentURL
	 */
    public void setServiceDocumentURL(String serviceDocumentURL)
	{
	    this.serviceDocumentURL = serviceDocumentURL;
	    
	    if (this.serviceDocumentURL.length() > 0)
	    {
	    	if (this.service == null)
	    	{
	    		this.service = new ZUSERSERVICE_SRVService(context);
	    	}
	    	
	        this.service.setUrl(serviceDocumentURL);
	    }
	}
	
	/**
     * Sets the SAP-Client.
     * @param serviceDocumentURL
     */
    public void setSAPClient(String client)
    {
        this.SAPClient = client;
        this.connectivityHelper.setSAPClient(client);
    }
    
	/**
	 * Sets whether to use the service document and metadata resources from the local files,
	 * or to fetch them on-line in the login process.
	 */	
	public void setUseLocalMetadata(boolean useLocalMetadata) 
	{
		this.useLocalMetadata = useLocalMetadata;
	}
	
    /**
     * Sets whether the service negotiation process should be performed as part of the login process.
     * This is considered only when the useLocalMetadata property is set to false.
     */
    public void setUseServiceNegotiation(boolean useServiceNegotiation)
    {
    	this.useServiceNegotiation = useServiceNegotiation;
    }
    
    /**
     * Add Expand String to ODataQuery object
     */
    private ODataQuery appendExpandStrings(ODataQuery query, String... toExpand) throws UnsupportedEncodingException 
	{
		StringBuffer sb = new StringBuffer();
		
		for (String navigationToExpand : toExpand) 
		{
			if (navigationToExpand.trim().length() > 0)
			{
				sb.append(navigationToExpand);
				sb.append(',');
			}
		}
		
		String toExpandString = sb.toString();
		int lastIndexOf = toExpandString.lastIndexOf(',');
		if(lastIndexOf > 0)
		{
			toExpandString = toExpandString.subSequence(0, lastIndexOf).toString();
		}
		
		if (toExpandString.trim().length() > 0)
		{
			query.expand(toExpandString);
		}
		
		return query;
	}
	



	/**
     * Executes a request for a Users.
     */
    public void loadUsers()
    {
        try
        {
            // get the query from the proxy
            ODataQuery query = this.service.getUsersQuery();
            
			// checking if in batch mode
            if (this.connectivityHelper.getBatchRequest() != null)
            {
                this.connectivityHelper.addRetrieveRequestToBatch(query, ZUSERSERVICE_SRVRequestID.LOAD_USERS.name());
            } 
			else
			{
				// add the gwpa-action header to the request
	            ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(ZUSERSERVICE_SRVRequestID.LOAD_USERS.name());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
	            
	            // execute the query by the connectivity helper
	            this.connectivityHelper.executeBasicAsyncRequest(query, this);
	            
	            // unregister the gwpa-action delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
			}
        } 
        catch (MalformedURLException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.LOAD_USERS, null, requestStatus);
            return;
        } 
        catch (ConnectivityException e2)
        {
            this.logger.e(TAG, e2.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e2, e2.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.LOAD_USERS, null, requestStatus);
            return;
        }
    }
    
    /*
     * This method checks for valid response, parses it 
     * and notifies the listener.
     */
    private void loadUsersCompleted(ZUSERSERVICE_SRVRequestID requestID, IResponse aResponse)
    {
        RequestStatus requestStatus;
        List<User> entries = null;
        String message = null;
        
        // check for valid response
        if (aResponse == null) 
        {
            requestStatus = new RequestStatus(StatusType.PARSE_ERROR, null, "The response is null");
            this.logger.e(TAG, "loadUsersCompleted method: the response is null");
            // notify listeners
            notifyListenersForRequestCompleted(requestID, null, requestStatus);
            return;
        }
        
        try
        {
            // parse the data into a list of User entries
            String data = EntityUtils.toString(aResponse.getEntity(), "UTF-8");
            entries = this.service.getUsers(data);
            
            requestStatus = new RequestStatus(StatusType.OK, null, null);
        } 
        catch (ParseException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }   
            else
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        } 
        catch (IOException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }
            else
            {
                requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        }
        catch (ParserException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }
            else
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        }
        
        // notify the listeners with the response, that might include an error response
        notifyListenersForRequestCompleted(requestID, entries, requestStatus);
    }



    
    /**
     * Executes a request for a single User entry.
     */
    public void loadUsersEntry(String Username) 
    {
        try
        {
            // get the query from the proxy
            ODataQuery query = this.service.getUsersEntryQuery(Username);

			// checking if in batch mode
            if (this.connectivityHelper.getBatchRequest() != null)
            {
                this.connectivityHelper.addRetrieveRequestToBatch(query, ZUSERSERVICE_SRVRequestID.LOAD_USERS_ENTRY.name());
            } 
            else
            {
				// add the gwpa-action header to the request
	            ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(ZUSERSERVICE_SRVRequestID.LOAD_USERS_ENTRY.name());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
	
	            // execute the query by the connectivity helper
	            this.connectivityHelper.executeBasicAsyncRequest(query, this);
	            
	            // unregister the gwpa-action delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
	        }
        } 
        catch (MalformedURLException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.LOAD_USERS_ENTRY, null, requestStatus);
            return;
        }
		catch (UnsupportedEncodingException e1) 
        {
        	this.logger.e(TAG, e1.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e1, e1.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.LOAD_USERS_ENTRY, null, requestStatus);
            return;
		} 
		catch (ConnectivityException e2)
        {
            this.logger.e(TAG, e2.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e2, e2.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.LOAD_USERS_ENTRY, null, requestStatus);
            return;
        }
    }
    




 	/**
     * This method checks for valid response, parses it 
     * and notifies the listener.
     */
    private void loadUsersEntryCompleted(ZUSERSERVICE_SRVRequestID requestID, IResponse aResponse)
    {
        RequestStatus requestStatus;
        // a single User is represented by a list of size 1
        List<User> entries = null;
        String message = null;
        
        // check for valid response
        if (aResponse == null) 
        {
            requestStatus = new RequestStatus(StatusType.PARSE_ERROR, null, "The response is null");
            this.logger.e(TAG, "loadUserCompleted method: the response is null");
            // notify listeners
            notifyListenersForRequestCompleted(requestID, null, requestStatus);
            return;
        }
        
        try
        {
            // parse the data into a list of User entries
            String data = EntityUtils.toString(aResponse.getEntity(), "UTF-8");
            
            if (data.trim().equals(""))
            {
           		requestStatus = new RequestStatus(StatusType.OK, null, null);
           		notifyListenersForRequestCompleted(requestID, null, requestStatus);
           		return;
            }
            
            User entry = this.service.getUsersEntry(data);
            entries = new ArrayList<User>();
            entries.add(entry);
            
            requestStatus = new RequestStatus(StatusType.OK, null, null);
        } 
        catch (ParseException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }   
            else
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        } 
        catch (IOException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }
            else
            {
                requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG,"Error response from server: " + message);
            }
        }
        catch (ParserException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            }
            else
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        }
        
        // notify listeners of the response, that might include an error response
        notifyListenersForRequestCompleted(requestID, entries, requestStatus);
    }

 	/**
     * Executes a create request for a single User entry.
     */
    public void createUsersEntry(User entry)
    {
        try
        {
            // get the query from the proxy
            ODataQuery query = this.service.getUsersQuery();
            
            // put in the map
            this.requestsIdentifierMap.put(ZUSERSERVICE_SRVRequestID.CREATE_USERS_ENTRY, entry);
            
            if (this.connectivityHelper.getBatchRequest() != null)
            {
                String contentType = "application/atom+xml";
                byte[] data = null;
                if (this.useJson)
                {
                    contentType = "application/json";
                    data = entry.getJsonStringPayload(this.service.getParser(), this.service.getSchema(), "Users")
                            .getBytes();
                } 
                else
                {
                    data = entry.getStringPayload().getBytes();
                }
                // Add request to a change set
                this.connectivityHelper.addRequestToChangeset(query, BaseRequest.REQUEST_METHOD_POST, contentType, "Users", data, ZUSERSERVICE_SRVRequestID.CREATE_USERS_ENTRY.name());
            } 
            else
            {
	            // add the gwpa-action header to the request
	            ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(ZUSERSERVICE_SRVRequestID.CREATE_USERS_ENTRY.name());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
	            
	            // add the content-type header to the request
	            ContentTypeHelperDelegateImpl contentTypeDelegate = new ContentTypeHelperDelegateImpl(this.isUseJson());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(contentTypeDelegate);
	            
	            // execute the query by the connectivity helper
		        if (!this.useJson)
		        {
		        	this.connectivityHelper.executeAsyncCreateRequest(query, entry.getXmlStringPayload(), this);
		        }
		        else
		        {
		        	this.connectivityHelper.executeAsyncCreateRequest(query, 
		        						entry.getJsonStringPayload(this.service.getParser(), this.service.getSchema(), "Users"), 
		        						this);
		        }
	            
	            // unregister the gwpa-action delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
	            // unregister the content-type delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(contentTypeDelegate);
            }
        } 
        catch (MalformedURLException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.CREATE_USERS_ENTRY, null, requestStatus);
            return;
        }
        catch (ParserException e)
        {
             this.logger.e(TAG, e.getLocalizedMessage());
             RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
             notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.CREATE_USERS_ENTRY, null, requestStatus);
             return;
        } 
        catch (ConnectivityException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
        }
    }

	/**
     * Executes an update request for a single User entry.
     */
    public void updateUsersEntry(User entry)
    {
        try
        {
            // get the query from the entry
            ODataQuery query = new ODataQuery(entry.getEntry().getId());
            
            // put in the map
            this.requestsIdentifierMap.put(ZUSERSERVICE_SRVRequestID.UPDATE_USERS_ENTRY, entry);
            
            if (this.connectivityHelper.getBatchRequest() != null)
            {
                String contentType = "application/atom+xml";
                byte[] data = null;
                if (this.useJson)
                {
                    contentType = "application/json";
                    data = entry.getJsonStringPayload(this.service.getParser(), this.service.getSchema(), "Users")
                            .getBytes();
                } 
                else
                {
                    data = entry.getStringPayload().getBytes();
                }
                
                // Add request to a change set
                this.connectivityHelper.addRequestToChangeset(query, BaseRequest.REQUEST_METHOD_PUT, 
                contentType, "Users", data, ZUSERSERVICE_SRVRequestID.UPDATE_USERS_ENTRY.name());
            } 
            else
            {
	            // add the gwpa-action header to the request
	            ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(ZUSERSERVICE_SRVRequestID.UPDATE_USERS_ENTRY.name());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
	            
	            // add the content-type header to the request
	            ContentTypeHelperDelegateImpl contentTypeDelegate = new ContentTypeHelperDelegateImpl(this.isUseJson());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(contentTypeDelegate);
	            
	            // execute the query by the connectivity helper
	            if (!this.useJson)
	            {
		        	this.connectivityHelper.executeAsyncUpdateRequest(query, entry.getXmlStringPayload(), this);
		        }
		        else
		        {
		        	this.connectivityHelper.executeAsyncUpdateRequest(query, entry.getJsonStringPayload(this.service.getParser(),this.service.getSchema(),"Users"), this);
		        }
	            
	            // unregister the gwpa-action delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
	            // unregister the content-type delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(contentTypeDelegate);
            }
        } 
        catch (MalformedURLException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.UPDATE_USERS_ENTRY, null, requestStatus);
            return;
        }
        catch (ParserException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.UPDATE_USERS_ENTRY, null, requestStatus);
            return;
        } 
        catch (ConnectivityException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
        }
    }

	/**
     * Executes a delete request for a single User entry.
     */
    public void deleteUsersEntry(User entry)
    {
        try
        {
            // get the query from the entry
            ODataQuery query = new ODataQuery(entry.getEntry().getId());
            
            // put in the map
            this.requestsIdentifierMap.put(ZUSERSERVICE_SRVRequestID.DELETE_USERS_ENTRY, entry);
            
            if (this.connectivityHelper.getBatchRequest() != null)
            {
             	String contentType = "application/atom+xml";
                byte[] data = null;
                if (this.useJson)
                {
                    contentType = "application/json";
                    data = entry.getJsonStringPayload(this.service.getParser(), this.service.getSchema(), "Users")
                            .getBytes();
                } 
                else
                {
                    data = entry.getStringPayload().getBytes();
                }
                
                // Add request to a change set
                this.connectivityHelper.addRequestToChangeset(query, BaseRequest.REQUEST_METHOD_DELETE,
                contentType, "Users", data, ZUSERSERVICE_SRVRequestID.DELETE_USERS_ENTRY.name());
            }
            else
            {
	            // add the gwpa-action header to the request
	            ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(ZUSERSERVICE_SRVRequestID.DELETE_USERS_ENTRY.name());
	            this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
	            
	            // execute the query by the connectivity helper
		        if (!this.useJson)
		        {
		        	this.connectivityHelper.executeAsyncDeleteRequest(query, this);
		        }
		        else
		        {
		        	this.connectivityHelper.executeAsyncDeleteRequest(query, this);
		        }
	            
	            // unregister the gwpa-action delegate
	            this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
            }
        } 
        catch (MalformedURLException e)
        {
             this.logger.e(TAG, e.getLocalizedMessage());
             RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
             notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.DELETE_USERS_ENTRY, null, requestStatus);
             return;
        }
        catch (ParserException e)
        {
             this.logger.e(TAG, e.getLocalizedMessage());
             RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
             notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID.DELETE_USERS_ENTRY, null, requestStatus);
             return;
        }
        catch (ConnectivityException e)
        {
            this.logger.e(TAG, e.getLocalizedMessage());
        }
    }




    /**
     * The request reaches here when it succeeds.
     */
    public void onSuccess(IRequest aRequest, IResponse aResponse)
    {
        // get the request ID from the header
        String id = aRequest.getHeaders().get(GWPA_ACTION);
        
        if (id.equalsIgnoreCase("batch"))
        {
            batchCompleted(aRequest, aResponse);
            return;
        }
        
        ZUSERSERVICE_SRVRequestID requestID = ZUSERSERVICE_SRVRequestID.valueOf(id);
        
        if (requestID == null)
        {
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, null, "Couldn't find the request ID of the given request URL");
            this.logger.e(TAG, "Error in onSuccess method: couldn't find the request ID of the given request URL");
            // notify listeners
            notifyListenersForRequestCompleted(null, null, requestStatus);
            return;
        }
        
        switch (requestID)
        {
		case LOAD_USERS:
        {
            loadUsersCompleted(requestID, aResponse);
            break;
        }
        case LOAD_USERS_ENTRY:
        {
            loadUsersEntryCompleted(requestID, aResponse);
            break;
        }
        case CREATE_USERS_ENTRY:
        {
            loadUsersEntryCompleted(requestID, aResponse);
            break;
        }
        case UPDATE_USERS_ENTRY:
        {
            loadUsersEntryCompleted(requestID, aResponse);
            break;
        }
        case DELETE_USERS_ENTRY:
        {
            loadUsersEntryCompleted(requestID, aResponse);
            break;
        }
        default:
            break; 
        }
        this.requestsIdentifierMap.remove(requestID);
    }
    
    
    
    /**
     * The request comes here in case of an error occurred.
     */
    public void onError(IRequest aRequest, IResponse aResponse,
            IRequestStateElement aRequestStateElement)
    {
       // get the request ID from the map
        String id = aRequest.getHeaders().get(GWPA_ACTION);
        
        ZUSERSERVICE_SRVRequestID requestID;
        if (id.equalsIgnoreCase("batch"))
        {
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, null, null);
            notifyListenersForBatchCompleted(id, aResponse, requestStatus);
            return;
        }
        else
        {
            requestID = ZUSERSERVICE_SRVRequestID.valueOf(id);
            
            this.requestsIdentifierMap.remove(requestID);
        }
        
        final int errorcode = aRequestStateElement.getErrorCode();
        String emessage = "";
        boolean authenticationNeeded = false;
        
        switch (errorcode)
        {
        case RequestStateElement.AUTHENTICATION_ERROR:
            emessage = "Authentication error.";
            authenticationNeeded = true;
            break;
        case RequestStateElement.CLIENT_ERROR:
            emessage = "Client error.";
            break;
        case RequestStateElement.HTTP_ERROR:
            emessage = "HTTP error.";
            break;
        case RequestStateElement.NETWORK_ERROR:
            emessage = "Network error.";
            break;
        case RequestStateElement.PARSE_ERROR:
            emessage = "Parse error.";
            break;
        default:
            if (emessage.length() != 0)
            {
                break;
            }
            emessage = "Unknown error.";
            this.logger.e(TAG,
                    "Error while performing request: library error: unknown value in RequestStateElement.getErrorCode()");
            break;
        }
        
        // get the exception - if any
        final Exception e = aRequestStateElement.getException();
        // exception may be null
        if (e != null)
        {
            String messageString = "Error in making request. \n" + e.toString();
            this.logger.e(TAG + ": " + emessage, messageString);
            
            if (authenticationNeeded)
            {
            	removeJsonHeaders();
                notifyListenersForAuthentication(e.getLocalizedMessage());
                return;
            }
            
            RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e, e.getLocalizedMessage());
            notifyListenersForRequestCompleted(requestID, null, requestStatus);
        }
        else // no exception
        {
            try
            {
                if (null != aResponse)
                {
                    String responseString = parseErrorResponseFromServer(aResponse);
                    if (responseString != null)
                    {
                        this.logger.e(TAG + ": " + emessage, responseString);
                        
                        if (authenticationNeeded)
                        {
                            notifyListenersForAuthentication(responseString);
                            return;
                        }
                        
                        RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, null, responseString);
                        notifyListenersForRequestCompleted(requestID, null, requestStatus);
                    }
                }
            }
            catch (org.apache.http.ParseException e1)
            {
                this.logger.e(TAG + ": " + emessage, e1.getLocalizedMessage());
                
                RequestStatus requestStatus = new RequestStatus(StatusType.SERVER_ERROR, e1, e1.getLocalizedMessage());
                notifyListenersForRequestCompleted(requestID, null, requestStatus);
            }
        }
    }

    /*
     * Parses the error response coming from the server,
     * and returns null if there isn't one.
     */
    private String parseErrorResponseFromServer(IResponse aResponse)
    {
        String responseString = "";
        String response = null;
        
        HttpEntity responseEntity = aResponse.getEntity();
        if (responseEntity == null)
        {
        	return null;
        }
        
        try
        {
            response = EntityUtils.toString(responseEntity, "UTF-8");
        } 
        catch (ParseException e)
        {
            return null;
        } 
        catch (IOException e)
        {
            return null;
        }
                
        if(!useJson)
        {
	        Pattern pattern = Pattern.compile("<message.*>(.*)</message>");
	        Matcher matcher = pattern.matcher(response);
	        while (matcher.find())
	        {
	            responseString = matcher.group(1);
	        }
        }else{
        	try {
        	    JSONObject jsonErrorObject = new JSONObject(response);
        	    JSONObject errorMessageJsonObject = jsonErrorObject.getJSONObject("error").getJSONObject("message");
        	    responseString = errorMessageJsonObject.getString("value");
        	} catch (JSONException e) {
        		return null;
        	}
        }
        return responseString;
    }
    
    
    /**
     * Registers the given listener to the Request Handler.
     * 
     * @param newListener - the listener to register.
     * @param requestIDs - may be passed as a single request ID or as a sequence of request IDs.
     */
    public void register(IZUSERSERVICE_SRVRequestHandlerListener newListener, ZUSERSERVICE_SRVRequestID... requestIDs)
    {
        ListenerWrapper listenerWrapper = new ListenerWrapper(newListener, requestIDs);
        this.listenerWrappers.add(listenerWrapper);
    }
    
    /**
     * Unregisters the given listener.
     * @param deleteListener - the listener to unregister.
     */
    public void unregister(IZUSERSERVICE_SRVRequestHandlerListener deleteListener)
    {
        for (ListenerWrapper listenerWrapper : this.listenerWrappers)
        {
            IZUSERSERVICE_SRVRequestHandlerListener listener = listenerWrapper.getListener();
            if (listener.equals(deleteListener))
            {
                int listenerWrapperIndex =  this.listenerWrappers.indexOf(listenerWrapper);
                this.listenerWrappers.remove(listenerWrapperIndex);
            }
        }
    }
    
    
    /**
     * Notifies the listeners only regarding the requests they've registered to.
     * 
     * @param requestID - the request ID.
     * @param entries - the parsed entries.
     * @param requestStatus - the status of the request (OK, ERROR, etc.)
     */
    public void notifyListenersForRequestCompleted(ZUSERSERVICE_SRVRequestID requestID, List<?> entries, RequestStatus requestStatus) 
    {
        // go over all listener wrappers
        for (ListenerWrapper listenerWrapper : this.listenerWrappers)
        {
            List<ZUSERSERVICE_SRVRequestID> requestIDs = listenerWrapper.getRequestIDs();
            for (ZUSERSERVICE_SRVRequestID listenerRequestID : requestIDs)
            {
                // check if the given request is the request the listener has registered to
                if (listenerRequestID == requestID)
                {
                    // only if so, notify the listener
                    IZUSERSERVICE_SRVRequestHandlerListener listener = listenerWrapper.getListener();
                    listener.requestCompleted(requestID, entries, requestStatus);
                }
            }
        }
    }
    
    /**
     * Notify all listeners when authentication is needed.
     */
    public void notifyListenersForAuthentication(String message) 
    {
        // go over all listener wrappers
        for (ListenerWrapper listenerWrapper : this.listenerWrappers)
        {
            IZUSERSERVICE_SRVRequestHandlerListener listener = listenerWrapper.getListener();
            listener.authenticationNeeded(message);
        }
    }
    
    /**
     * Returns the connectivity helper class.
     * @return - connectivity helper class.
     */
    public SDMConnectivityHelper getConnectivityHelper() 
    {
		return connectivityHelper;
	}
	
	/**
     * Returns the ServiceDocument class.
     * @return - ServiceDocument class.
     */
	 public IODataServiceDocument getService() 
	 {
	  	return this.service.getServiceDocument();
	 }
	 
	/**
     * Initiates a batch request object which all following calls made by the RequestHandler will be aggregated into. 
     * Optionally the method receives a notification id string that users can listen on and get notified once batch is completed
     * 
     * @param batchId - id of batch request.
     */
    public void startBatch(String batchId)
    {
        this.connectivityHelper.startBatch(batchId, this.service.getBaseUrl());
    }
	 
	 
	/**
     * Executes the batch request initiated in the startBatch method.
     */
    public void executeBatch()
    {
        if (this.connectivityHelper.getBatchRequest() != null)
        {
            try
            {
                // add the gwpa-action header to the request
                ActionHelperDelegateImpl actionDelegate = new ActionHelperDelegateImpl(BATCH);
                        
                this.connectivityHelper.registerSDMConnectivityHelperDelegate(actionDelegate);
                
                this.connectivityHelper.executeAsyncBatchRequest(this);
                
                // unregister the gwpa-action delegate
                this.connectivityHelper.unregisterSDMConnectivityHelperDelegate(actionDelegate);
                
                // cleans the batch object
                this.connectivityHelper.setBatchRequest(null);

            } 
            catch (MalformedURLException e1)
            {
                this.logger.e(TAG + ": " + "MalformedURLException", e1.getLocalizedMessage());
            }
        }
    }

    /**
     * Closes existing changeset.
     */
    public void closeExistingChangeset() 
    {
        if (this.connectivityHelper.getBatchRequest() != null)
        {
            try
            {
                this.connectivityHelper.getBatchRequest().closeExistingChangeSet();
            } 
            catch (ConnectivityException e)
            {
                this.logger.e(TAG + ": " + "ConnectivityException", e.getLocalizedMessage());
            }
        }
    }
    
    private void batchCompleted(IRequest aRequest, IResponse aResponse)
    {
        RequestStatus requestStatus;
        String message = null;

        // get the batch ID from the header
        String batchId = aRequest.getHeaders().get(GWPA_BATCH_ACTION);

        // check for valid response
        if (aResponse == null)
        {
            requestStatus = new RequestStatus(StatusType.PARSE_ERROR, null, "The response is null");
            this.logger.e(TAG, "batchCompleted method: the response is null");
            notifyListenersForBatchCompleted(batchId, aResponse, requestStatus);
            return;
        }

        try
        {
            HashMap<IRequest, HttpResponse> batchResponseMap = aResponse.getBatchResponseMap();
            Set<IRequest> keySet = batchResponseMap.keySet();
            for (IRequest iRequest : keySet)
            {
                // build IResponse to pass to onSuccess/onError
                HttpResponse httpResponse = batchResponseMap.get(iRequest);
                IResponse res = new ResponseImpl((BasicStatusLine) httpResponse.getStatusLine());
                res.setEntity(httpResponse.getEntity());
                if (httpResponse.getStatusLine().getStatusCode() == 400 || httpResponse.getStatusLine().getStatusCode() == 500)
                {
                    IRequestStateElement stateElement = new RequestStateElement();
                    stateElement.setErrorCode(0);
                    onError(iRequest, res, stateElement);
                }
                else
                {
                    onSuccess(iRequest, res);
                }
            }

            requestStatus = new RequestStatus(StatusType.OK, null, null);
        } 
        catch (ParseException e)
        {
            message = parseErrorResponseFromServer(aResponse);
            if (message == null)
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, e.getLocalizedMessage());
                this.logger.e(TAG, e.getLocalizedMessage());
            } 
            else
            {
                requestStatus = new RequestStatus(StatusType.PARSE_ERROR, e, message);
                this.logger.e(TAG, e.getLocalizedMessage());
                this.logger.e(TAG, "Error response from server: " + message);
            }
        }

        // notify the listeners with the response, that might include an error
        notifyListenersForBatchCompleted(batchId, aResponse, requestStatus);
    }

    private void notifyListenersForBatchCompleted(String batchId, IResponse aResponse, RequestStatus requestStatus)
    {
        // go over all listener wrappers
        for (ListenerWrapper listenerWrapper : this.listenerWrappers)
        {
            // only if so, notify the listener
            IZUSERSERVICE_SRVRequestHandlerListener listener = listenerWrapper.getListener();
            listener.batchCompleted(batchId, aResponse, requestStatus);
        }
    }
}
